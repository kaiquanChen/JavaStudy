## 1.JDK和JRE
1. JDK:支持Java程序开发的最小环境,Java程序设计语言, Java虚拟机, Java API类库三部分组成JDK.
2. JRE:支持Java程序运行的标准环境,JavaSE API和Java虚拟机两部分组成了JRE.

## 2.JVM内存区域划分
![](./images/jvmstructure.png)

### 2.1.线程独有的内存区域
1. PC,当前线程所执行的字节码的行号指示器
2. JAVA STACK,虚拟机栈:生命周期和线程相同,每个方法执行的同事都会创建一个栈帧,用于存储局部变量表,
操作数栈,动态连接和方法出口等信息.
3. NATIVE METHOD STACK,方法栈:

### 2.2.线程间共享的内存区域
1. HEAP,堆:存放对象实例,目前垃圾算法都是分代收集算法,堆分为新生代和老年代.
2. METHOD AREA,方法去:存储虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码.
3. RUNTIME CONSTANT POOL,运行时常量池:用于存放编译期间生成的各种字面量和符号引用.在类加载后进入
进入运行时常量池中.(String.intern():如果常量池中有该String对象则返回引用;否则将该对象加入常量池
中并返回引用)

## 3.Java垃圾回收(GC)
### 3.1.堆内润回收
1. 引用计数法(Java未使用这种算法):一个对象如果被引用计数值+1;当引用失效,计数值-1;当计数值为0时的
对象就不再使用.但种算法很难解决对象中相互引用的问题.

2. 可达性分析:通过"GC Roots"的对象作为起始点,向下搜索,所走过的路径称为引用链,当一个对象没有任何引
用的时(不可达),则证明此对象不可用.

- 强引用: Student s = new Student();垃圾回收绝不会回收这类对象
- 软运用: 还有用但是非必需的对象,会被进行二次回收
- 弱引用: 描述非必需对象,只能生存到下次垃圾回收之前
- 徐引用: 被收集器回收时收到一个系统通知

### 3.2.方法区回收
- 主要回收目标是:废弃常量和无用类
1. 废弃常量:当前系统没有任何移除引用该常量
2. 无用类:
    + 该类所有实例都已经被回收
    + 加载该类的ClassLoader已经被回收
    + 该类在Java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法
    
### 3.3.垃圾回收算法
1. 标记-清除算法:先标记后清除;然而两个过程效率都不高,并且会产生内存碎片
2. 复制算法:将内存分为凉快,每次只使用其中一块,当这一块内存用完时,将存货的对象复制到另外一块中,然后再
对已经使用过的一块进行一次性清理;然而内存缩小为原来的一半,适合于回收新生代
3. 标记-整理算法:将存活的对象移动到一端,然后直接清理掉边界意外的内存
4. 分代收集算法:新生代采用复制算法;老年代采用标记-整理算法

