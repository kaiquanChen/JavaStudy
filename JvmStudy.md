## 1.JDK和JRE
1. JDK:支持Java程序开发的最小环境,Java程序设计语言, Java虚拟机, Java API类库三部分组成JDK.
2. JRE:支持Java程序运行的标准环境,JavaSE API和Java虚拟机两部分组成了JRE.

## 2.JVM内存区域划分
![](./images/jvmstructure.png)

### 2.1.线程独有的内存区域
1. PC,当前线程所执行的字节码的行号指示器
2. JAVA STACK,虚拟机栈:生命周期和线程相同,每个方法执行的同事都会创建一个栈帧,用于存储局部变量表,
操作数栈,动态连接和方法出口等信息.
3. NATIVE METHOD STACK,方法栈:

### 2.2.线程间共享的内存区域
1. HEAP,堆:存放对象实例,目前垃圾算法都是分代收集算法,堆分为新生代和老年代.
2. METHOD AREA,方法去:存储虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码.
3. RUNTIME CONSTANT POOL,运行时常量池:用于存放编译期间生成的各种字面量和符号引用.在类加载后进入
进入运行时常量池中.(String.intern():如果常量池中有该String对象则返回引用;否则将该对象加入常量池中并返回引用)

## 3.Java垃圾回收(GC)
### 3.1.堆内存回收
1. 引用计数法(Java未使用这种算法):一个对象如果被引用计数值+1;当引用失效,计数值-1;当计数值为0时的
对象就不再使用.但种算法很难解决对象中相互引用的问题.

2. 可达性分析:通过"GC Roots"的对象作为起始点,向下搜索,所走过的路径称为引用链,当一个对象没有任何引
用的时(不可达),则证明此对象不可用.

- 强引用: Student s = new Student();垃圾回收绝不会回收这类对象
- 软引用: 还有用但是非必需的对象,会被进行二次回收
- 弱引用: 描述非必需对象,只能生存到下次垃圾回收之前
- 徐引用: 被收集器回收时收到一个系统通知

### 3.2.方法区回收
- 主要回收目标是:废弃常量和无用类
1. 废弃常量:当前系统没有任何一处引用该常量
2. 无用类:
    + 该类所有实例都已经被回收
    + 加载该类的ClassLoader已经被回收
    + 该类在Java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法
    
### 3.3.垃圾回收算法
1. 标记-清除算法:先标记后清除;然而两个过程效率都不高,并且会产生内存碎片
2. 复制算法:将内存分为凉快,每次只使用其中一块,当这一块内存用完时,将存货的对象复制到另外一块中,然后再
对已经使用过的一块进行一次性清理;然而内存缩小为原来的一半,适合于回收新生代
3. 标记-整理算法:将存活的对象移动到一端,然后直接清理掉边界意外的内存
4. 分代收集算法:新生代采用复制算法;老年代采用标记-整理算法

## 4.内存溢出和内存泄露
1. 内存溢出:程序在申请内存空间时,没有足够大的空间可以分配(内存不足)
2. 内存泄露:被分配的对象可达,但是无用;内存泄露终将导致内存溢出

# 5.JVM类加载机制
- 类加载机制分为五部分:加载,验证,准备,解析,初始化,使用,卸载
![](./images/Jvm1.png)

## 5.1.加载:
会生成一个代表这个类的Java.lang.Class对象,Class对象可以从Class文件,jar包或者war包,也可以运行时计算生成
(动态代理),或者其他文件生成(JSP文件转化为Class文件)

## 5.2.验证:
确保Class文件的字节流中包含的信息是否符合当前虚拟机的规范并且不会危害虚拟机.

## 5.3.准备:
为类变量分配内存并设置类变量的初始值,即在方法区中分配这些变量所使用的内存空间.

## 5.4.解析:
虚拟机将常量池中的符号引用替换为直接引用的过程.

## 5.5.初始化:
初始化阶段是执行类构造器<client>方法的过程.<client>方法由编译器自动收集类中的类变量的赋值操作和静态语句块中
的语句合并而成.

不会执行类初始化的情况:
- 子类引用父类的静态字段,只会触发父类的初始化.
- 定义对象数组不会出发该类的初始化
- 通过类名获取Class对象

## 5.6.类加载器:
1. 启动类加载器(Bootstrap ClassLoader):负责加载JAVA_HOME\lib下的核心目录
2. 扩展类加载器(Extension ClassLoader):负责加载JAVA_HOME\lib\ext目录
3. 应用程序类加载器(Application ClassLoader):负责加载用户路径上的类库

- 双亲委托机制:
当一个类加载器收到类加载任务,会先交给父类加载器去完成,因此都会到达启动类加载器,只有当父类加载器无法完成加载任务时,才会自己去加载.